# coding: utf-8

import json
import sys
reload(sys)
sys.setdefaultencoding('utf8')


# function_real_list 中存在 call_info={'class': ***, 'method': ***, ['args': {'0': ***, ...}]} 的调用
def has_call(function_real_list, call_info):
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            if call_info['args']:
                match_args = call_info['args']
                for single_call in function_real['call_list']:
                    args_real = single_call['args']
                    flag = True
                    for match_position in match_args.keys():
                        if args_real[int(match_position)] != match_args.get(match_position):
                            flag = False
                            break
                    if flag:
                        return True
            else:
                return True
    return False

# function_real_list 中存在 call_info={'class': ***, 'method': ***, ['args': {'0': 包含字符串'***', ...}]} 的调用
def has_call_args_contain(function_real_list, call_info):
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            if call_info['args']:
                match_args = call_info['args']
                for single_call in function_real['call_list']:
                    args_real = single_call['args']
                    flag = True
                    for match_position in match_args.keys():
                        try:
                            args_real[int(match_position)].index(match_args.get(match_position))
                        except ValueError as err:
                            flag = False
                            break
                    if flag:
                        return True
            else:
                return True
    return False








# WebView 远程代码执行漏洞
def detection_webview_exec(function_real_list, app_info, result_list):
    call_info = {
        'class': 'android.webkit.WebView', 
        'method': 'addJavascriptInterface', 
    }
    if has_call(function_real_list, call_info) and int(app_info['min_sdk']) < 17:
        result_list.append(u'WebView 远程代码执行漏洞')
    return result_list

# WebView密码明文存储漏洞
def detection_webview_plaintext(function_real_list, result_list):
    call_info_loadUrl = {
        'class': 'android.webkit.WebView', 
        'method': 'loadUrl', 
    }
    call_info_setSavePassWord = {
        'class': 'android.webkit.WebView', 
        'method': 'setSavePassword', 
        'args': {'0': 'false'}, 
    }
    if has_call(function_real_list, call_info_loadUrl) and not has_call(function_real_list, call_info_setSavePassWord):
        result_list.append(u'WebView密码明文存储漏洞')
    return result_list

# WebView隐藏接口未移除漏洞
def detection_webview_hide_api(function_real_list, result_list):
    call_info_loadUrl = {
        'class': 'android.webkit.WebView', 
        'method': 'loadUrl', 
    }
    call_info_removeJavascriptInterface_searchBox = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'searchBoxJavaBridge_'}, 
    }
    call_info_removeJavascriptInterface_accessibility = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'accessibility'}, 
    }
    call_info_removeJavascriptInterface_accessibilityTraversal = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'accessibilityTraversal'}, 
    }
    if has_call(function_real_list, call_info_loadUrl):
        if not has_call(function_real_list, call_info_removeJavascriptInterface_searchBox) or not has_call(function_real_list, call_info_removeJavascriptInterface_accessibility) or not has_call(function_real_list, call_info_removeJavascriptInterface_accessibilityTraversal):
            result_list.append(u'WebView隐藏接口未移除漏洞')
    return result_list

# WebView File域同源策略绕过漏洞
def detection_webview_file_bypass(function_real_list, result_list):
    call_info_setJavaScriptEnabled = {
        'class': 'android.webkit.WebSettings', 
        'method': 'setJavaScriptEnabled', 
        'args': {'0': 'true'}, 
    }
    call_info_setAllowFileAccess = {
        'class': 'android.webkit.WebSettings', 
        'method': 'setAllowFileAccess', 
        'args': {'0': 'false'}, 
    }
    if has_call(function_real_list, call_info_setJavaScriptEnabled) and not has_call(function_real_list, call_info_setAllowFileAccess):
        result_list.append(u'WebView File域同源策略绕过漏洞')
    return result_list

# 忽略SSL证书验证错误漏洞
def detection_ssl_proceed(function_real_list, result_list):
    call_info_proceed = {
        'class': 'android.webkit.SslErrorHandler', 
        'method': 'proceed', 
    }
    if has_call(function_real_list, call_info_proceed):
        result_list.append(u'忽略SSL证书验证错误漏洞')
    return result_list

# SharedPreferences任意读写漏洞
def detection_sharedpreferences_arbitrarity(function_real_list, result_list):
    call_info_getSharedPreferences_read = {
        'class': 'android.content.Context', 
        'method': 'getSharedPreferences', 
        'args': {'1': '1'}, 
    }
    call_info_getSharedPreferences_write = {
        'class': 'android.content.Context', 
        'method': 'getSharedPreferences', 
        'args': {'1': '2'}, 
    }
    if has_call(function_real_list, call_info_getSharedPreferences_read) or has_call(function_real_list, call_info_getSharedPreferences_write):
        result_list.append(u'SharedPreferences任意读写漏洞')
    return result_list

# 文件任意读写漏洞
def detection_file_arbitrarity(function_real_list, result_list):
    call_info_openFileOutput_read = {
        'class': 'android.content.Context', 
        'method': 'openFileOutput', 
        'args': {'1': '1'}, 
    }
    call_info_openFileOutput_write = {
        'class': 'android.content.Context', 
        'method': 'openFileOutput', 
        'args': {'1': '2'}, 
    }
    if has_call(function_real_list, call_info_openFileOutput_read) or has_call(function_real_list, call_info_openFileOutput_write):
        result_list.append(u'文件任意读写漏洞')
    return result_list

# 主机名弱校验漏洞
def detection_hostname_weak_check(function_real_list, result_list):
    call_info_setHostnameVerifier = {
        'class': 'javax.net.ssl.HttpsURLConnection', 
        'method': 'setHostnameVerifier', 
        'args': {'0': 'org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER'}, 
    }
    if has_call(function_real_list, call_info_setHostnameVerifier):
        result_list.append(u'主机名弱校验漏洞')
    return result_list

# Dex文件动态加载 (风险漏洞)
def detection_dex_load(function_real_list, result_list):
    call_info_DexClassLoader = {
        'class': 'dalvik.system.DexClassLoader', 
        'method': 'DexClassLoader', 
        'args': {'0': 'sdcard'}, 
    }
    call_info_loadDex_0 = {
        'class': 'dalvik.system.DexFile', 
        'method': 'loadDex', 
        'args': {'0': 'sdcard'}, 
    }
    call_info_loadDex_1 = {
        'class': 'dalvik.system.DexFile', 
        'method': 'loadDex', 
        'args': {'1': 'sdcard'}, 
    }
    
    if has_call_args_contain(function_real_list, call_info_DexClassLoader) or has_call_args_contain(function_real_list, call_info_loadDex_0) or has_call_args_contain(function_real_list, call_info_loadDex_1):
        result_list.append(u'Dex文件动态加载 (风险漏洞)')
    return result_list










def transfer_func_to_vul(function_real_list, app_info):
    vulnerabilities = []
    
    return vulnerabilities