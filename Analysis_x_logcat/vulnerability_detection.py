# coding: utf-8

import json
import sys
reload(sys)
sys.setdefaultencoding('utf8')

from Global import add_api_position_single_api

# function_real_list 中存在 call_info={'class': ***, 'method': ***, 'args': {'0': ***, ...}} 的调用
def has_call(function_real_list, call_info):
    api_positions = set()
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            try:
                match_args = call_info['args']
            except KeyError as err:
                api_positions = add_api_position_single_api(api_positions, function_real['exception_positions'])
                continue
            for single_call in function_real['call_list']:
                args_real = single_call['args']
                flag = True
                for match_position in match_args.keys():
                    if args_real[int(match_position)] != match_args.get(match_position):
                        flag = False
                        break
                if flag:
                    api_positions = add_api_position_single_api(api_positions, single_call['exception_positions'])
    return list(api_positions)

# function_real_list 中存在 call_info={'class': ***, 'method': ***, 'args': {'0': 包含字符串'***', ...}} 的调用
def has_call_args_contain(function_real_list, call_info):
    api_positions = set()
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            try:
                match_args = call_info['args']
            except KeyError as err:
                api_positions = add_api_position_single_api(api_positions, function_real['exception_positions'])
                continue
            for single_call in function_real['call_list']:
                args_real = single_call['args']
                flag = True
                for match_position in match_args.keys():
                    try:
                        args_real[int(match_position)].index(match_args.get(match_position))
                    except ValueError as err:
                        flag = False
                        break
                if flag:
                    api_positions = add_api_position_single_api(api_positions, single_call['exception_positions'])
    return list(api_positions)

# function_real_list 中存在 call_info={'class': ***, 'method': ***} 第一个参数总相同的调用
def has_call_first_args_same(function_real_list, call_info):
    api_positions = set()
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            if len(function_real['call_list']) == 1:
                continue
            flag = True
            first_args = function_real['call_list'][0]['args'][0]
            for single_call in function_real['call_list'][1:]:
                args_real = single_call['args']
                if args_real[0] != first_args:
                    flag = False
                    break
            if flag:
                api_positions = add_api_position_single_api(api_positions, function_real['exception_positions'])
    return list(api_positions)

# function_real_list 中存在 call_info={'class': ***, 'method': ***} 调用时传递了参数
def has_call_exist_args(function_real_list, call_info):
    api_positions = set()
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            for single_call in function_real['call_list']:
                if single_call['args']:
                    api_positions = add_api_position_single_api(api_positions, single_call['exception_positions'])
    return list(api_positions)





# WebView 远程代码执行漏洞
def detection_webview_exec(function_real_list, app_info, result_list):
    call_info = {
        'class': 'android.webkit.WebView', 
        'method': 'addJavascriptInterface', 
    }
    api_positions = has_call(function_real_list, call_info)
    if api_positions and int(app_info['min_sdk']) < 17:
        result_list.append({'L2017040001': api_positions})
    return result_list

# WebView密码明文存储漏洞
def detection_webview_plaintext(function_real_list, result_list):
    call_info_loadUrl = {
        'class': 'android.webkit.WebView', 
        'method': 'loadUrl', 
    }
    call_info_setSavePassWord = {
        'class': 'android.webkit.WebView', 
        'method': 'setSavePassword', 
        'args': {'0': 'false'}, 
    }
    api_positions_loadUrl = has_call(function_real_list, call_info_loadUrl)
    if api_positions_loadUrl and not has_call(function_real_list, call_info_setSavePassWord):
        result_list.append({'L2017040002': api_positions_loadUrl})
    return result_list

# WebView隐藏接口未移除漏洞
def detection_webview_hide_api(function_real_list, result_list):
    call_info_loadUrl = {
        'class': 'android.webkit.WebView', 
        'method': 'loadUrl', 
    }
    call_info_removeJavascriptInterface_searchBox = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'searchBoxJavaBridge_'}, 
    }
    call_info_removeJavascriptInterface_accessibility = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'accessibility'}, 
    }
    call_info_removeJavascriptInterface_accessibilityTraversal = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'accessibilityTraversal'}, 
    }
    api_positions_loadUrl = has_call(function_real_list, call_info_loadUrl)
    if api_positions_loadUrl:
        if not has_call(function_real_list, call_info_removeJavascriptInterface_searchBox) or not has_call(function_real_list, call_info_removeJavascriptInterface_accessibility) or not has_call(function_real_list, call_info_removeJavascriptInterface_accessibilityTraversal):
            result_list.append({'L2017040016': api_positions_loadUrl})
    return result_list

# WebView File域同源策略绕过漏洞
def detection_webview_file_bypass(function_real_list, result_list):
    call_info_setJavaScriptEnabled = {
        'class': 'android.webkit.WebSettings', 
        'method': 'setJavaScriptEnabled', 
        'args': {'0': 'true'}, 
    }
    call_info_setAllowFileAccess = {
        'class': 'android.webkit.WebSettings', 
        'method': 'setAllowFileAccess', 
        'args': {'0': 'false'}, 
    }
    api_positions = has_call(function_real_list, call_info_setJavaScriptEnabled)
    if api_positions and not has_call(function_real_list, call_info_setAllowFileAccess):
        result_list.append({'L2017040017': api_positions})
    return result_list

# 忽略SSL证书验证错误漏洞
def detection_ssl_proceed(function_real_list, result_list):
    call_info_proceed = {
        'class': 'android.webkit.SslErrorHandler', 
        'method': 'proceed', 
    }
    api_positions = has_call(function_real_list, call_info_proceed)
    if api_positions:
        result_list.append({'L2017040004': api_positions})
    return result_list

# SharedPreferences任意读写漏洞
def detection_sharedpreferences_arbitrarity(function_real_list, result_list):
    call_info_getSharedPreferences_read = {
        'class': 'android.content.Context', 
        'method': 'getSharedPreferences', 
        'args': {'1': '1'}, 
    }
    call_info_getSharedPreferences_write = {
        'class': 'android.content.Context', 
        'method': 'getSharedPreferences', 
        'args': {'1': '2'}, 
    }
    api_positions_read = has_call(function_real_list, call_info_getSharedPreferences_read)
    api_positions_write = has_call(function_real_list, call_info_getSharedPreferences_write)
    if api_positions_read or api_positions_write:
        result_list.append({'L2017040003': api_positions_read + api_positions_write})
    return result_list

# 文件任意读写漏洞
def detection_file_arbitrarity(function_real_list, result_list):
    call_info_openFileOutput_read = {
        'class': 'android.content.Context', 
        'method': 'openFileOutput', 
        'args': {'1': '1'}, 
    }
    call_info_openFileOutput_write = {
        'class': 'android.content.Context', 
        'method': 'openFileOutput', 
        'args': {'1': '2'}, 
    }
    api_positions_read = has_call(function_real_list, call_info_openFileOutput_read)
    api_positions_write = has_call(function_real_list, call_info_openFileOutput_write)
    if api_positions_read or api_positions_write:
        result_list.append({'L2017040007': api_positions_read + api_positions_write})
    return result_list

# 主机名弱校验漏洞
def detection_hostname_weak_check(function_real_list, result_list):
    call_info_setHostnameVerifier = {
        'class': 'javax.net.ssl.HttpsURLConnection', 
        'method': 'setHostnameVerifier', 
        'args': {'0': 'org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER'}, 
    }
    api_positions = has_call(function_real_list, call_info_setHostnameVerifier)
    if api_positions:
        result_list.append({'L2017040006': api_positions})
    return result_list

# Dex文件动态加载 (风险漏洞)
def detection_dex_load(function_real_list, result_list):
    call_info_DexClassLoader = {
        'class': 'dalvik.system.DexClassLoader', 
        'method': 'DexClassLoader', 
        'args': {'0': 'sdcard'}, 
    }
    call_info_loadDex_0 = {
        'class': 'dalvik.system.DexFile', 
        'method': 'loadDex', 
        'args': {'0': 'sdcard'}, 
    }
    call_info_loadDex_1 = {
        'class': 'dalvik.system.DexFile', 
        'method': 'loadDex', 
        'args': {'1': 'sdcard'}, 
    }
    api_positions_DexClassLoader = has_call_args_contain(function_real_list, call_info_DexClassLoader)
    api_positions_loadDex_0 = has_call_args_contain(function_real_list, call_info_loadDex_0)
    api_positions_loadDex_1 = has_call_args_contain(function_real_list, call_info_loadDex_1)
    if api_positions_DexClassLoader or api_positions_loadDex_0 or api_positions_loadDex_1:
        result_list.append({'L2017040008': api_positions_DexClassLoader + api_positions_loadDex_0 + api_positions_loadDex_1})
    return result_list

# 密钥硬编码漏洞
def detection_secretKey(function_real_list, result_list):
    call_info_SecretKeySpec = {
        'class': 'javax.crypto.spec.SecretKeySpec', 
        'method': 'SecretKeySpec', 
    }
    api_positions = has_call_first_args_same(function_real_list, call_info_SecretKeySpec)
    if api_positions:
        result_list.append({'L2017040009': api_positions})
    return result_list

# AES/DES弱加密漏洞
def detection_aes_des_weak(function_real_list, result_list):
    call_info_getInstance = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
    }
    call_info_getInstance_contain_rsa = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'RSA'}, 
    }
    call_info_getInstance_contain_ecb = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'ECB'}, 
    }
    call_info_getInstance_des = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'DES'}, 
    }
    call_info_getInstance_aes = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'AES'}, 
    }
    call_info_getInstance_desede = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'DESede'}, 
    }
    if has_call(function_real_list, call_info_getInstance) and not has_call_args_contain(function_real_list, call_info_getInstance_contain_rsa):
        api_positions_ecb = has_call_args_contain(function_real_list, call_info_getInstance_contain_ecb)
        api_positions_des = has_call(function_real_list, call_info_getInstance_des)
        api_positions_aes = has_call(function_real_list, call_info_getInstance_aes)
        api_positions_desede = has_call(function_real_list, call_info_getInstance_desede)
        if api_positions_ecb or api_positions_des or api_positions_aes or api_positions_desede:
            result_list.append({'L2017040014': api_positions_ecb + api_positions_des + api_positions_aes + api_positions_desede})
    return result_list

# 密文初始化向量硬编码漏洞
def detection_crypt_iv(function_real_list, result_list):
    call_info_IvParameterSpec = {
        'class': 'javax.crypto.spec.IvParameterSpec', 
        'method': 'IvParameterSpec', 
    }
    api_positions = has_call_first_args_same(function_real_list, call_info_IvParameterSpec)
    if api_positions:
        result_list.append({'L2017040023': api_positions})
    return result_list

# 随机数使用不当漏洞
def detection_random_wrong(function_real_list, app_info, result_list):
    call_info_SecureRandom = {
        'class': 'java.security.SecureRandom', 
        'method': 'SecureRandom', 
    }
    call_info_setSeed = {
        'class': 'java.security.SecureRandom', 
        'method': 'setSeed', 
    }
    if int(app_info['min_sdk']) < 17:
        api_positions_SecureRandom = has_call_exist_args(function_real_list, call_info_SecureRandom)
        api_positions_setSeed = has_call_exist_args(function_real_list, call_info_setSeed)
        if api_positions_SecureRandom or api_positions_setSeed:
            result_list.append({'L2017040012': api_positions_SecureRandom + api_positions_setSeed})
    return result_list

# 运行其它可执行程序（风险漏洞）
def detection_run_program(function_real_list, result_list):
    call_info_exec = {
        'class': 'java.lang.Runtime', 
        'method': 'exec', 
    }
    api_positions = has_call(function_real_list, call_info_exec)
    if api_positions:
        result_list.append({'L2017040011': api_positions})
    return result_list

# Intent scheme url漏洞
def detection_intent_scheme(function_real_list, result_list):
    call_info_parseUri = {
        'class': 'android.content.Intent', 
        'method': 'parseUri', 
        'args': {'0': 'intent:'}, 
    }
    call_info_addCategory = {
        'class': 'android.content.Intent', 
        'method': 'addCategory', 
        'args': {'0': 'android.intent.category.BROWSABLE'}, 
    }
    call_info_setComponent = {
        'class': 'android.content.Intent', 
        'method': 'setComponent', 
        'args': {'0': 'null'}, 
    }
    call_info_setSelector = {
        'class': 'android.content.Intent', 
        'method': 'setSelector', 
        'args': {'0': 'null'}, 
    }
    api_positions_parseUri = has_call_args_contain(function_real_list, call_info_parseUri)
    if api_positions_parseUri:
        if not has_call(function_real_list, call_info_addCategory) or not has_call(function_real_list, call_info_setComponent) or not has_call(function_real_list, call_info_setSelector):
            result_list.append({'L2017040022': api_positions_parseUri})
    return result_list

def make_vul_data(function_real_list, app_info):
    vulnerabilities = []
    
    vulnerabilities = detection_webview_exec(function_real_list, app_info, vulnerabilities)
    vulnerabilities = detection_webview_plaintext(function_real_list, vulnerabilities)
    vulnerabilities = detection_webview_hide_api(function_real_list, vulnerabilities)
    vulnerabilities = detection_webview_file_bypass(function_real_list, vulnerabilities)
    vulnerabilities = detection_ssl_proceed(function_real_list, vulnerabilities)
    vulnerabilities = detection_sharedpreferences_arbitrarity(function_real_list, vulnerabilities)
    vulnerabilities = detection_file_arbitrarity(function_real_list, vulnerabilities)
    vulnerabilities = detection_hostname_weak_check(function_real_list, vulnerabilities)
    vulnerabilities = detection_dex_load(function_real_list, vulnerabilities)
    vulnerabilities = detection_secretKey(function_real_list, vulnerabilities)
    vulnerabilities = detection_aes_des_weak(function_real_list, vulnerabilities)
    vulnerabilities = detection_crypt_iv(function_real_list, vulnerabilities)
    vulnerabilities = detection_random_wrong(function_real_list, app_info, vulnerabilities)
    vulnerabilities = detection_run_program(function_real_list, vulnerabilities)
    vulnerabilities = detection_intent_scheme(function_real_list, vulnerabilities)
    
    return vulnerabilities

def transfer_func_to_vul(function_real_list, app_info):
    vulnerabilities_dict = {}
    
    vulnerabilities_list = make_vul_data(function_real_list, app_info)
    for vulnerabilities in vulnerabilities_list:
        vulnerabilities_dict = dict(vulnerabilities_dict, **vulnerabilities)
    
    return vulnerabilities_dict