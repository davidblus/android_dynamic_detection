# coding: utf-8

import json
import sys
reload(sys)
sys.setdefaultencoding('utf8')


# function_real_list 中存在 call_info={'class': ***, 'method': ***, 'args': {'0': ***, ...}} 的调用
def has_call(function_real_list, call_info):
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            try:
                match_args = call_info['args']
            except KeyError as err:
                return True
            for single_call in function_real['call_list']:
                args_real = single_call['args']
                flag = True
                for match_position in match_args.keys():
                    if args_real[int(match_position)] != match_args.get(match_position):
                        flag = False
                        break
                if flag:
                    return True
    return False

# function_real_list 中存在 call_info={'class': ***, 'method': ***, 'args': {'0': 包含字符串'***', ...}} 的调用
def has_call_args_contain(function_real_list, call_info):
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            try:
                match_args = call_info['args']
            except KeyError as err:
                return True
            for single_call in function_real['call_list']:
                args_real = single_call['args']
                flag = True
                for match_position in match_args.keys():
                    try:
                        args_real[int(match_position)].index(match_args.get(match_position))
                    except ValueError as err:
                        flag = False
                        break
                if flag:
                    return True
    return False

# function_real_list 中存在 call_info={'class': ***, 'method': ***} 第一个参数总相同的调用
def has_call_first_args_same(function_real_list, call_info):
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            if len(function_real['call_list']) == 1:
                return False
            first_args = function_real['call_list'][0]['args'][0]
            for single_call in function_real['call_list'][1:]:
                args_real = single_call['args']
                if args_real[0] != first_args:
                    return False
            return True
    return False

# function_real_list 中存在 call_info={'class': ***, 'method': ***} 调用时传递了参数
def has_call_exist_args(function_real_list, call_info):
    for function_real in function_real_list:
        if function_real['class'] == call_info['class'] and function_real['method'] == call_info['method']:
            for single_call in function_real['call_list']:
                if single_call['args']:
                    return True
    return False





# WebView 远程代码执行漏洞
def detection_webview_exec(function_real_list, app_info, result_list):
    call_info = {
        'class': 'android.webkit.WebView', 
        'method': 'addJavascriptInterface', 
    }
    if has_call(function_real_list, call_info) and int(app_info['min_sdk']) < 17:
        result_list.append(u'WebView 远程代码执行漏洞')
    return result_list

# WebView密码明文存储漏洞
def detection_webview_plaintext(function_real_list, result_list):
    call_info_loadUrl = {
        'class': 'android.webkit.WebView', 
        'method': 'loadUrl', 
    }
    call_info_setSavePassWord = {
        'class': 'android.webkit.WebView', 
        'method': 'setSavePassword', 
        'args': {'0': 'false'}, 
    }
    if has_call(function_real_list, call_info_loadUrl) and not has_call(function_real_list, call_info_setSavePassWord):
        result_list.append(u'WebView密码明文存储漏洞')
    return result_list

# WebView隐藏接口未移除漏洞
def detection_webview_hide_api(function_real_list, result_list):
    call_info_loadUrl = {
        'class': 'android.webkit.WebView', 
        'method': 'loadUrl', 
    }
    call_info_removeJavascriptInterface_searchBox = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'searchBoxJavaBridge_'}, 
    }
    call_info_removeJavascriptInterface_accessibility = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'accessibility'}, 
    }
    call_info_removeJavascriptInterface_accessibilityTraversal = {
        'class': 'android.webkit.WebView', 
        'method': 'removeJavascriptInterface', 
        'args': {'0': 'accessibilityTraversal'}, 
    }
    if has_call(function_real_list, call_info_loadUrl):
        if not has_call(function_real_list, call_info_removeJavascriptInterface_searchBox) or not has_call(function_real_list, call_info_removeJavascriptInterface_accessibility) or not has_call(function_real_list, call_info_removeJavascriptInterface_accessibilityTraversal):
            result_list.append(u'WebView隐藏接口未移除漏洞')
    return result_list

# WebView File域同源策略绕过漏洞
def detection_webview_file_bypass(function_real_list, result_list):
    call_info_setJavaScriptEnabled = {
        'class': 'android.webkit.WebSettings', 
        'method': 'setJavaScriptEnabled', 
        'args': {'0': 'true'}, 
    }
    call_info_setAllowFileAccess = {
        'class': 'android.webkit.WebSettings', 
        'method': 'setAllowFileAccess', 
        'args': {'0': 'false'}, 
    }
    if has_call(function_real_list, call_info_setJavaScriptEnabled) and not has_call(function_real_list, call_info_setAllowFileAccess):
        result_list.append(u'WebView File域同源策略绕过漏洞')
    return result_list

# 忽略SSL证书验证错误漏洞
def detection_ssl_proceed(function_real_list, result_list):
    call_info_proceed = {
        'class': 'android.webkit.SslErrorHandler', 
        'method': 'proceed', 
    }
    if has_call(function_real_list, call_info_proceed):
        result_list.append(u'忽略SSL证书验证错误漏洞')
    return result_list

# SharedPreferences任意读写漏洞
def detection_sharedpreferences_arbitrarity(function_real_list, result_list):
    call_info_getSharedPreferences_read = {
        'class': 'android.content.Context', 
        'method': 'getSharedPreferences', 
        'args': {'1': '1'}, 
    }
    call_info_getSharedPreferences_write = {
        'class': 'android.content.Context', 
        'method': 'getSharedPreferences', 
        'args': {'1': '2'}, 
    }
    if has_call(function_real_list, call_info_getSharedPreferences_read) or has_call(function_real_list, call_info_getSharedPreferences_write):
        result_list.append(u'SharedPreferences任意读写漏洞')
    return result_list

# 文件任意读写漏洞
def detection_file_arbitrarity(function_real_list, result_list):
    call_info_openFileOutput_read = {
        'class': 'android.content.Context', 
        'method': 'openFileOutput', 
        'args': {'1': '1'}, 
    }
    call_info_openFileOutput_write = {
        'class': 'android.content.Context', 
        'method': 'openFileOutput', 
        'args': {'1': '2'}, 
    }
    if has_call(function_real_list, call_info_openFileOutput_read) or has_call(function_real_list, call_info_openFileOutput_write):
        result_list.append(u'文件任意读写漏洞')
    return result_list

# 主机名弱校验漏洞
def detection_hostname_weak_check(function_real_list, result_list):
    call_info_setHostnameVerifier = {
        'class': 'javax.net.ssl.HttpsURLConnection', 
        'method': 'setHostnameVerifier', 
        'args': {'0': 'org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER'}, 
    }
    if has_call(function_real_list, call_info_setHostnameVerifier):
        result_list.append(u'主机名弱校验漏洞')
    return result_list

# Dex文件动态加载 (风险漏洞)
def detection_dex_load(function_real_list, result_list):
    call_info_DexClassLoader = {
        'class': 'dalvik.system.DexClassLoader', 
        'method': 'DexClassLoader', 
        'args': {'0': 'sdcard'}, 
    }
    call_info_loadDex_0 = {
        'class': 'dalvik.system.DexFile', 
        'method': 'loadDex', 
        'args': {'0': 'sdcard'}, 
    }
    call_info_loadDex_1 = {
        'class': 'dalvik.system.DexFile', 
        'method': 'loadDex', 
        'args': {'1': 'sdcard'}, 
    }
    
    if has_call_args_contain(function_real_list, call_info_DexClassLoader) or has_call_args_contain(function_real_list, call_info_loadDex_0) or has_call_args_contain(function_real_list, call_info_loadDex_1):
        result_list.append(u'Dex文件动态加载 (风险漏洞)')
    return result_list

# 密钥硬编码漏洞
def detection_secretKey(function_real_list, result_list):
    call_info_SecretKeySpec = {
        'class': 'javax.crypto.spec.SecretKeySpec', 
        'method': 'SecretKeySpec', 
    }
    if has_call_first_args_same(function_real_list, call_info_SecretKeySpec):
        result_list.append(u'密钥硬编码漏洞')
    return result_list

# AES/DES弱加密漏洞
def detection_aes_des_weak(function_real_list, result_list):
    call_info_getInstance = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
    }
    call_info_getInstance_contain_rsa = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'RSA'}, 
    }
    call_info_getInstance_contain_ecb = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'ECB'}, 
    }
    call_info_getInstance_des = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'DES'}, 
    }
    call_info_getInstance_aes = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'AES'}, 
    }
    call_info_getInstance_desede = {
        'class': 'javax.crypto.Cipher', 
        'method': 'getInstance', 
        'args': {'0': 'DESede'}, 
    }
    if has_call(function_real_list, call_info_getInstance) and not has_call_args_contain(function_real_list, call_info_getInstance_contain_rsa):
        if has_call_args_contain(function_real_list, call_info_getInstance_contain_ecb) or has_call(function_real_list, call_info_getInstance_des) or has_call(function_real_list, call_info_getInstance_aes) or has_call(function_real_list, call_info_getInstance_desede):
            result_list.append(u'AES/DES弱加密漏洞')
    return result_list

# 密文初始化向量硬编码漏洞
def detection_crypt_iv(function_real_list, result_list):
    call_info_IvParameterSpec = {
        'class': 'javax.crypto.spec.IvParameterSpec', 
        'method': 'IvParameterSpec', 
    }
    if has_call_first_args_same(function_real_list, call_info_IvParameterSpec):
        result_list.append(u'密文初始化向量硬编码漏洞')
    return result_list

# 随机数使用不当漏洞
def detection_random_wrong(function_real_list, app_info, result_list):
    call_info_SecureRandom = {
        'class': 'java.security.SecureRandom', 
        'method': 'SecureRandom', 
    }
    call_info_setSeed = {
        'class': 'java.security.SecureRandom', 
        'method': 'setSeed', 
    }
    if int(app_info['min_sdk']) < 17:
        if has_call_exist_args(function_real_list, call_info_SecureRandom) or has_call_exist_args(function_real_list, call_info_setSeed):
            result_list.append(u'随机数使用不当漏洞')
    return result_list

# 运行其它可执行程序（风险漏洞）
def detection_run_program(function_real_list, result_list):
    call_info_exec = {
        'class': 'java.lang.Runtime', 
        'method': 'exec', 
    }
    if has_call(function_real_list, call_info_exec):
        result_list.append(u'运行其它可执行程序（风险漏洞）')
    return result_list

# Intent scheme url漏洞
def detection_intent_scheme(function_real_list, result_list):
    call_info_parseUri = {
        'class': 'android.content.Intent', 
        'method': 'parseUri', 
        'args': {'0': 'intent:'}, 
    }
    call_info_addCategory = {
        'class': 'android.content.Intent', 
        'method': 'addCategory', 
        'args': {'0': 'android.intent.category.BROWSABLE'}, 
    }
    call_info_setComponent = {
        'class': 'android.content.Intent', 
        'method': 'setComponent', 
        'args': {'0': 'null'}, 
    }
    call_info_setSelector = {
        'class': 'android.content.Intent', 
        'method': 'setSelector', 
        'args': {'0': 'null'}, 
    }
    if has_call_args_contain(function_real_list, call_info_parseUri):
        if not has_call(function_real_list, call_info_addCategory) or not has_call(function_real_list, call_info_setComponent) or not has_call(function_real_list, call_info_setSelector):
            result_list.append(u'Intent scheme url漏洞')
    return result_list



def transfer_func_to_vul(function_real_list, app_info):
    vulnerabilities = []
    
    vulnerabilities = detection_webview_exec(function_real_list, app_info, vulnerabilities)
    vulnerabilities = detection_webview_plaintext(function_real_list, vulnerabilities)
    vulnerabilities = detection_webview_hide_api(function_real_list, vulnerabilities)
    vulnerabilities = detection_webview_file_bypass(function_real_list, vulnerabilities)
    vulnerabilities = detection_ssl_proceed(function_real_list, vulnerabilities)
    vulnerabilities = detection_sharedpreferences_arbitrarity(function_real_list, vulnerabilities)
    vulnerabilities = detection_file_arbitrarity(function_real_list, vulnerabilities)
    vulnerabilities = detection_hostname_weak_check(function_real_list, vulnerabilities)
    vulnerabilities = detection_dex_load(function_real_list, vulnerabilities)
    vulnerabilities = detection_secretKey(function_real_list, vulnerabilities)
    vulnerabilities = detection_aes_des_weak(function_real_list, vulnerabilities)
    vulnerabilities = detection_crypt_iv(function_real_list, vulnerabilities)
    vulnerabilities = detection_random_wrong(function_real_list, app_info, vulnerabilities)
    vulnerabilities = detection_run_program(function_real_list, vulnerabilities)
    vulnerabilities = detection_intent_scheme(function_real_list, vulnerabilities)
    
    return vulnerabilities